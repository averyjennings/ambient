import { existsSync, writeFileSync, mkdirSync } from "node:fs"
import { join, dirname } from "node:path"
import type { MemoryKey, ProjectMemory, ShellContext, TaskMemory } from "../types/index.js"
import { loadProjectMemory, loadTaskMemory } from "./store.js"

const CONTEXT_FILE_PATH = ".ambient/context.md"
const MAX_BYTES = 4096
const DEBOUNCE_MS = 1_000

/**
 * ContextFileGenerator manages the lifecycle of .ambient/context.md
 * in the project's git root. It merges project-level and task-level
 * memory into a markdown file that coding agents passively read.
 *
 * The generator is owned by the daemon and triggered by shell events.
 * It debounces rapid events to avoid excessive writes.
 */
export class ContextFileGenerator {
  private debounceTimer: ReturnType<typeof setTimeout> | null = null
  private lastContentHash = ""

  /**
   * Schedule a debounced regeneration. Multiple calls within
   * DEBOUNCE_MS coalesce into a single write.
   */
  scheduleRegeneration(gitRoot: string, shellCtx: ShellContext, memoryKey: MemoryKey): void {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer)
    }

    this.debounceTimer = setTimeout(() => {
      this.debounceTimer = null
      this.regenerate(gitRoot, shellCtx, memoryKey)
    }, DEBOUNCE_MS)
  }

  /**
   * Immediately regenerate the context file. Used for branch
   * switch and new session start (no debounce needed).
   */
  regenerateNow(gitRoot: string, shellCtx: ShellContext, memoryKey: MemoryKey): void {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer)
      this.debounceTimer = null
    }
    this.regenerate(gitRoot, shellCtx, memoryKey)
  }

  private regenerate(gitRoot: string, shellCtx: ShellContext, memoryKey: MemoryKey): void {
    try {
      const project = loadProjectMemory(memoryKey.projectKey)
      const task = loadTaskMemory(memoryKey.projectKey, memoryKey.taskKey)

      const content = renderContextMarkdown(shellCtx, memoryKey, project, task)

      // Skip write if content hasn't changed
      const contentHash = simpleHash(content)
      if (contentHash === this.lastContentHash) return
      this.lastContentHash = contentHash

      const filePath = join(gitRoot, CONTEXT_FILE_PATH)
      const dirPath = dirname(filePath)

      if (!existsSync(dirPath)) {
        mkdirSync(dirPath, { recursive: true })
      }

      writeFileSync(filePath, content, "utf-8")
    } catch {
      // Silently fail â€” context file is best-effort.
      // Handles read-only filesystems, permission errors, etc.
    }
  }
}

/**
 * Render merged context markdown. Sections are priority-ordered and
 * trimmed to stay within MAX_BYTES. Lower-priority sections are
 * dropped first.
 */
function renderContextMarkdown(
  shell: ShellContext,
  memoryKey: MemoryKey,
  project: ProjectMemory | null,
  task: TaskMemory | null,
): string {
  const sections: string[] = []

  // Header (always present)
  sections.push("<!-- Auto-generated by ambient. Do not edit. -->\n# Ambient Context\n")

  // Section 1: Project info
  const projectLines: string[] = []
  if (project || shell.projectInfo) {
    projectLines.push("## Project")
    if (shell.projectInfo?.framework) {
      projectLines.push(`- Framework: ${shell.projectInfo.framework}`)
    }
    if (shell.projectInfo?.packageManager) {
      projectLines.push(`- Package manager: ${shell.projectInfo.packageManager}`)
    }
    // Show high-importance project decisions
    if (project) {
      const decisions = project.events
        .filter((e) => e.type === "decision" && e.importance === "high")
        .slice(-5)
      for (const d of decisions) {
        projectLines.push(`- ${d.content}`)
      }
    }
    projectLines.push("")
    sections.push(projectLines.join("\n"))
  }

  // Section 2: Current task (branch-specific)
  if (task && task.events.length > 0 && memoryKey.branchName !== "default") {
    const taskLines: string[] = [`## Current Task (branch: ${memoryKey.branchName})`]
    const taskUpdates = task.events
      .filter((e) => e.type === "task-update")
      .slice(-3)
    for (const u of taskUpdates) {
      taskLines.push(`- ${u.content}`)
    }
    const taskDecisions = task.events
      .filter((e) => e.type === "decision")
      .slice(-5)
    for (const d of taskDecisions) {
      taskLines.push(`- Decision: ${d.content}`)
    }
    taskLines.push("")
    sections.push(taskLines.join("\n"))
  } else if (memoryKey.branchName !== "default") {
    sections.push(`## Current Branch: ${memoryKey.branchName}\n`)
  }

  // Section 3: Recent errors
  if (task) {
    const errors = task.events
      .filter((e) => e.type === "error-resolution")
      .slice(-5)
    if (errors.length > 0) {
      const errorLines: string[] = ["## Recent Errors"]
      for (const e of errors) {
        const fileNote = e.metadata?.["file"] ? ` in ${e.metadata["file"]}` : ""
        errorLines.push(`- ${e.content}${fileNote}`)
      }
      errorLines.push("")
      sections.push(errorLines.join("\n"))
    }
  }

  // Section 4: Key files
  if (task) {
    const files = task.events
      .filter((e) => e.type === "file-context")
      .slice(-10)
    if (files.length > 0) {
      const fileLines: string[] = ["## Key Files"]
      for (const f of files) {
        fileLines.push(`- ${f.content}`)
      }
      fileLines.push("")
      sections.push(fileLines.join("\n"))
    }
  }

  return trimToBytes(sections, MAX_BYTES)
}

/**
 * Assemble sections into a string that fits within maxBytes.
 * Drops sections from the end (lowest priority) first.
 * The header (section 0) is always kept.
 */
function trimToBytes(sections: string[], maxBytes: number): string {
  let result = ""
  for (const section of sections) {
    const candidate = result + section
    if (Buffer.byteLength(candidate, "utf-8") > maxBytes) {
      break
    }
    result = candidate
  }
  return result.trimEnd() + "\n"
}

/**
 * Fast non-cryptographic hash for content change detection.
 */
function simpleHash(str: string): string {
  let hash = 0
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i)
    hash = ((hash << 5) - hash + char) | 0
  }
  return hash.toString(36)
}
