import { describe, it, expect } from "vitest"

/**
 * Tests for the context file rendering logic.
 * We test the pure functions: trimToBytes, simpleHash, and the rendering structure.
 *
 * Since renderContextMarkdown and trimToBytes are private module functions,
 * we reproduce their logic here to test the contract.
 */

// Reproduce trimToBytes for testing
function trimToBytes(sections: string[], maxBytes: number): string {
  let result = ""
  for (const section of sections) {
    const candidate = result + section
    if (Buffer.byteLength(candidate, "utf-8") > maxBytes) {
      break
    }
    result = candidate
  }
  return result.trimEnd() + "\n"
}

// Reproduce simpleHash for testing
function simpleHash(str: string): string {
  let hash = 0
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i)
    hash = ((hash << 5) - hash + char) | 0
  }
  return hash.toString(36)
}

describe("trimToBytes", () => {
  it("includes all sections when under limit", () => {
    const sections = ["# Header\n", "## Section 1\n", "## Section 2\n"]
    const result = trimToBytes(sections, 2048)
    expect(result).toContain("# Header")
    expect(result).toContain("## Section 1")
    expect(result).toContain("## Section 2")
  })

  it("drops lower-priority sections when over limit", () => {
    const sections = [
      "# Header\n",
      "## Project\n- Info line\n",
      "## " + "x".repeat(2000) + "\n", // This section pushes over limit
    ]
    const result = trimToBytes(sections, 100)
    expect(result).toContain("# Header")
    expect(result).toContain("## Project")
    expect(result).not.toContain("xxx")
  })

  it("always includes at least the header", () => {
    const sections = ["# Header\n", "## " + "x".repeat(3000) + "\n"]
    const result = trimToBytes(sections, 2048)
    expect(result).toContain("# Header")
  })

  it("ends with a newline", () => {
    const result = trimToBytes(["# Test\n"], 2048)
    expect(result.endsWith("\n")).toBe(true)
  })

  it("handles empty sections array", () => {
    const result = trimToBytes([], 2048)
    expect(result).toBe("\n")
  })

  it("respects byte length for multibyte characters", () => {
    // Each emoji is 4 bytes in UTF-8, so 600 emojis = 2400+ bytes
    const emojiSection = "# " + "ðŸŽ‰".repeat(600) + "\n"
    const byteLength = Buffer.byteLength(emojiSection, "utf-8")
    expect(byteLength).toBeGreaterThan(2048)

    const result = trimToBytes(["# Header\n", emojiSection], 2048)
    expect(result).toContain("# Header")
    expect(result).not.toContain("ðŸŽ‰")
  })
})

describe("simpleHash", () => {
  it("returns consistent hashes for the same input", () => {
    const hash1 = simpleHash("test content")
    const hash2 = simpleHash("test content")
    expect(hash1).toBe(hash2)
  })

  it("returns different hashes for different inputs", () => {
    const hash1 = simpleHash("content A")
    const hash2 = simpleHash("content B")
    expect(hash1).not.toBe(hash2)
  })

  it("returns a non-empty string", () => {
    const hash = simpleHash("anything")
    expect(hash.length).toBeGreaterThan(0)
  })

  it("handles empty string", () => {
    const hash = simpleHash("")
    expect(hash).toBe("0")
  })
})

describe("context markdown structure", () => {
  it("renders a valid header section", () => {
    const header = "<!-- Auto-generated by ambient. Do not edit. -->\n# Ambient Context\n"
    expect(header).toContain("Auto-generated")
    expect(header).toContain("# Ambient Context")
  })

  it("renders project section with framework and package manager", () => {
    const projectLines = [
      "## Project",
      "- Framework: next",
      "- Package manager: pnpm",
      "",
    ]
    const section = projectLines.join("\n")
    expect(section).toContain("Framework: next")
    expect(section).toContain("Package manager: pnpm")
  })

  it("renders task section with branch name", () => {
    const branchName = "feature/memory-system"
    const taskLines = [
      `## Current Task (branch: ${branchName})`,
      "- Implementing two-level memory",
      "",
    ]
    const section = taskLines.join("\n")
    expect(section).toContain("branch: feature/memory-system")
  })
})
